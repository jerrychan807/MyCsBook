# 20180719-set

[TOC]

---

# preface:

今天做了一个Python脚本,功能是比较两个漏扫结果表(第一次扫描结果、第二次扫描结果)
![](https://ws1.sinaimg.cn/large/006tNc79gy1ftfmltepoqj30wy09mn8h.jpg)

找出当中的三种类型的漏洞：

- 未修复
- 已修复
- 新增

我一开始的思路就是

- 分别读取两个excel表中的漏洞记录存入两个列表a,b中
- 逐行比较

这样子的话要循环很多次，效率会很低
而Boss给了我一个思路,说他之前写的漏洞情况比较，用了set数据类型,操作起来很方便。

So,Let's start.

---

# Keyword : set

## What:

### 什么是set数据类型?

**Unordered collections of unique elements**
去重的无序集合

> 定义很重要

### set数据类型有哪些方法？

![](https://ws4.sinaimg.cn/large/006tNc79gy1ftfn8uqm38j31bi0gqh5q.jpg)

### set的分类：
原来set根据能否修改的特点还分两种:

- set
- ImmutableSet


![](https://ws2.sinaimg.cn/large/006tNc79gy1ftfnaacywgj31k80gg7qa.jpg)

可变的`set`比`ImmutableSet`多了这些方法，这让我联想到最近看的`fluent python`中的一张图，
![](https://ws4.sinaimg.cn/large/006tNc79gy1ftfnh099rij312e0dkq78.jpg)

---

### set缺点:

本来还想说set的缺点就是无序，会出现图的这种乱序现象。
![](https://ws1.sinaimg.cn/large/006tNc79gy1ftfnjlaeglj30l6052ado.jpg)

看了set的定义后，才知道是我自己的对`set`这个data model不了解
人家本来就是**去重的无序集合 Unordered collections of unique elements**

---

## Why:
### 为什么set操作起来的效率会更高?

- 第一次扫描结果,从Excel中读取出来后存入first_list
- 第二次扫描结果,从Excel中读取出来后存入second_list
- 假设长度均为100条

每次你需要比较一条数据的时候都要循环second_list一次，即100次
要比较完所有first_list中的数据的话，你总共需要循环100*100次

相比这种遍历的比较方式，相当于是自己定义的函数，肯定不及**内置类型自带的方法**快。

因为built-in type 及其方法 is implemented in C.

比如要你用了built-in type，你要计算数据的长度，你调用`len()`方法，它会走short-cut直接返回`ob_size`

![](https://ws3.sinaimg.cn/large/006tNc79gy1ftfnosw5xzj312i05uk18.jpg)

---

## How:

### 用了哪些函数?

```
#获取两个list 的交集
def same(a,b):
    return list(set(a).intersection(set(b)))

#获取两个list 的并集
def union(a,b):
    return list(set(a).union(set(b)))

#获取两个list 的差集 a中有而b中没有的
def diff(a,b):
    return list(set(a).difference(set(b)))
```

### 怎么样找出三种类型的漏洞?

a:第一次扫描结果
b:第二次扫描结果

- a与b的交集:
 - a和b共同出现过的漏洞，说明是未修复的 
- a与b的差集:
 - a中有而b中没有，说明是已修复的
 - a中没有而b中有，说明是新增的漏洞 

---

## When&Where:

### 什么时候什么场景会用到set?

先了解你的数据，再考虑需要用什么数据类型来存储

> 数据结构这个时候好像变得重要了起来啊....


---

## Who:

### Boss

看来有相关开发经验确实可以少走很多坑

> 姜还是老得辣啊。。。

---

## 拓展：


- 数据结构



