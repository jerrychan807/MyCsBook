#7.2 在子程序层上设计(Routine Level)
#目录：
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fhmaz1zl6zj30e00kcach.jpg)

---



**内聚性(cohesion)**是1974年的一篇论文提出的。

其中一些更为现代的概念，如**抽象**和**封装**等。

通常在**类**这一层次的设计中更为适用(事实上，**抽象**和**封装**在**类**层次上已经很大程度取代了**内聚性**).

但**内聚性的概念**仍然存在，而且在单个子程序这一层次上，仍是设计时常用的**启发式方法**。

---

##子程序的内聚性：
对子程序而言，内聚性是指**子程序中各种操作之间联系的紧密程度**。

例子：
Cosine()(余弦函数)这样的函数就是**极端内聚**的，因为整个程序**只完成一项功能**。

而CosineAndTan()(余弦与正切)这个函数的内聚性相对较弱，因为它完成了**多于一项的操作**。

##写子程序的目标：
让每一个子程序**只把一件事做好**，不再做任何其他事情。

##高内聚的好处：

- 得到更高的**可靠性**

> **高内聚性**的子程序中有50%没有任何错误，而**低内聚性**的子程序中只有18%是没有错误的。(1986)
> 
> ---
> **耦合度与内聚性之比**最高的那些子程序，其中所含的**错误**是**耦合度与内聚性之比**最低的子程序的7倍之多，而其**修正成本**则为20倍。(1991)

---


##内聚性的几个层次：
**理解**一些**概念**要比记住一些特定的术语更重要。

###功能的内聚性(functional cohesion)
**功能的内聚性**是最强也是最好的一种内聚性：让一个子程序**仅执行一项操作**。

例子：

- sin()
- GetCustomerName()
- EraseFile()
- CalculateLoanPayment()
- AgeFromBirthday()

---

不够理想的内聚性的种类：

- 顺序上的内聚性(sequential cohesion)
- 通信上的内聚性(communicational cohesion)
- 临时的内聚性(temporal cohesion)

###顺序上的内聚性(sequential cohesion)

顺序上的内聚性是指子程序内包含有**需要按特定顺序执行的操作**，这些步骤需要**共享数据**，而且只有在全部执行完毕后才完成了一项完整的功能。




###通信上的内聚性(communicational cohesion)
通信上的内聚性是指一个子程序中的**不同操作使用了同样的数据**，但**不存在其他任何联系**。



###临时的内聚性(temporal cohesion)
临时的内聚性是指含有一些因为**需要同时执行才放到一起的操作**的子程序。


---

##该使用哪种内聚性？
一般来说，除了功能上的的内聚性(functional cohesion)，其他类型的内聚性都是不可取的。

它们都会导致代码组织混乱、难于调试、不便修改。

如果一个子程序具有**不良的内聚性**，那最好还是花功夫重新编写，使其具有更好的**内聚性**，而不是再去花精力精确地诊断问题所在了。

因此，知道应该避免什么是非常有用的，下面是

**不可取的内聚性**

- 过程上的内聚性(procedural cohesion)
- 逻辑上的内聚性(logical cohesion)
- 巧合的内聚性(coincidental cohesion)

---

###过程上的内聚性(procedural cohesion)
过程上的内聚性是指一个子程序中的**操作是按特定的顺序**进行的。


###逻辑上的内聚性(logical cohesion)
逻辑上的内聚性是指若干操作被放入同一个子程序中，通过**传入的控制标志**选择执行其中的一项操作。


###巧合的内聚性(coincidental cohesion)
巧合的内聚性是指子程序中**各个操作之间没有任何可以看到的关联**，它也可称为“无内聚性”或“混乱的内聚性”。

---

##总结：

这些术语没有哪个是神秘的或者神圣不可侵犯的，需要理解的是**其中的想法**，而不是那些术语。

编写子程序时，要集中于**功能上的内聚性**。





