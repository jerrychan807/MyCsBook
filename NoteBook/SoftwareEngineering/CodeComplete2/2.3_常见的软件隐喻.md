# 2.3 常见的软件隐喻

<!-- TOC -->

- [2.3 常见的软件隐喻](#23-常见的软件隐喻)
    - [软件中的书法：写作代码](#软件中的书法写作代码)
        - [可修改性：](#可修改性)
        - [原创与重用：](#原创与重用)
    - [软件的耕作法: 培植系统](#软件的耕作法-培植系统)
    - [软件的牡蛎养殖观点：系统生长](#软件的牡蛎养殖观点系统生长)
        - [增量式开发步骤](#增量式开发步骤)
    - [软件构建：建造软件](#软件构建建造软件)
        - [简单的建筑：](#简单的建筑)
        - [复杂的建筑：](#复杂的建筑)
        - [精致的建筑：](#精致的建筑)
        - [两种活动的相似之处：](#两种活动的相似之处)
        - [隐喻的启发：](#隐喻的启发)
    - [应用软件技术：智慧工具箱](#应用软件技术智慧工具箱)
    - [组合各个隐喻](#组合各个隐喻)

<!-- /TOC -->

---

有很多关于软件开发的隐喻：

- 一门科学
- 一门艺术
- 一个过程
- 驾驶汽车
- 一场游戏
- 一个集市
- 园艺

---

## 软件中的书法：写作代码

关于软件开发的**最原始的隐喻**是从**“写作(writing)代码**这个说法发展出来的，这一隐喻暗示着开发一个程序就像写一封有缘由的信一样——坐下来，从头到尾写完，不需要正规地做计划，你想到什么东西把它写出来就是了。

对于个人规模的工作乃至小型的项目来说，这种写信的隐喻已经足够了。


然而对于其他场合而言，这个隐喻还远远不够——它没有完整、充分地刻画客户软件开发工作。


### 可修改性：
书写通常只是个人的活动，而一个软件项目多半会涉及承担许多不同职责的很多人。在你写完一封信之后，你只要把它塞进信封然后寄出去就完了，你再也不能修改它————而**软件的修改没那么难，也很难说有真正完全结束的时候**。

![](https://raw.githubusercontent.com/jerrychan807/imggg/master/006tNc79gy1fsahio9z9mj30so0b677k.jpg)

### 原创与重用：
对写作而已，最重要的是其**原创性**。但是对于软件构建来说，“努力创造真正的原创成果”的开发效率，往往低于专注于**重用(reuse)**以往项目的一些设计思想、代码以及测试用例(test case)的开发效率。

总之，写作这一隐喻所暗示的软件开发过程太过简单、呆板。


---

## 软件的耕作法: 培植系统

一些软件开发人员则认为应当将**创造软件**想象成类似**播种和耕种**的情形。

你一次设计系统的一小部分、写出一段代码、做一点测试，并将成果一点点添加到整个系统中。通过这种小步前进，你可以把每次可能遇到的麻烦减到最小。

“每次做一点”这个主意可能在某些方面与农作物生长类似，但把软件开发类比作为耕作就很不贴切，也没有太多意义。

**软件耕种**这一隐喻的**弱点**在于**它暗示了人们将无法对开发软件的过程和方式进行任何直接的控制。**

![](https://raw.githubusercontent.com/jerrychan807/imggg/master/006tNc79gy1fsakfqdf7uj30r40amdj7.jpg)


---

## 软件的牡蛎养殖观点：系统生长

跟生长密切相关的另一些词语有

- 增量的(incremental)
- 迭代的(iterative)
- 自适应的(adaptive)
- 演进的(evolutionary)

**以增量方式进行设计、编译和测试**，都是目前已知最强有力的软件开发概念。

### 增量式开发步骤
在进行增量式开发时，我们先做出软件系统的一个**尽可能简单、但能运行的版本**。

它不必接受真实的输入，也无须对数据进行真正的处理，更不用产生真实的输出————**它仅仅需要构成一个足够强壮的骨架**，支撑起未来将要开发的真实系统。

对于你标志出的每一项基本功能，可能仅需要调用**虚假的类(dummy class)**。就像牡蛎开始孕育珍珠的那颗细小沙粒。

在骨架形成之后，你要一点点地在其上附着肌肉和皮肤：把每个虚假的类替换为真正的类：不再假装接受输入和产生输出。一次增加一小部分代码，直到得到一个完全可以工作的系统。

作为一个隐喻而言，增量式开发的优势在于**未做过度的承诺**。

---

## 软件构建：建造软件


建造软件暗示了软件开发中存在着诸多阶段，如计划、准备及执行等，根据所建造软件的不同，这些阶段的种类和程度可能会发生变化。


### 简单的建筑：

在弄简单的建筑，如果错了，损失最多的也就是一个下午时间。这种宽松的方式对于小型的项目来说也还算合适。如果你写1000行代码时采用了错误的设计，你还可以重构或者从头再来，不会损失太多。

![](https://raw.githubusercontent.com/jerrychan807/imggg/master/006tKfTcgy1fshfx5x7ftj30r40f0juu.jpg)



### 复杂的建筑：

如果你是在建一栋房子，那么这个建造过程就会复杂得多，而糟糕的设计所引发的后果也更严重。

- **问题定义(problem definition)**：首先你要决定准备建一个什么类型的房子
- **软件架构设计(architectural design)**：必须和某个建筑师探讨这一总体设计，并得到批准
- **软件的构建(construction)**：准备好建造地点、打好地基、搭建房屋框架、砌好边墙、盖好房顶、通好水电煤气等
- **软件的优化(oprimization)**：这种房子大部分完成之后，要对新盖的家美化一番
- **软件复查(review)、审查(inspection)**：监查人员来检查工地、地基。布线以及其他需要检查的地方



> 程序员就像建筑师一样，在github提交的代码，就像你对外人展示你所建的建筑。向热门的github提供代码，就像一起搬砖一样。(2018.6.20)



### 精致的建筑：

如果你要建造一间拥有一流家具的高档住宅，那你可能需要特别订制的橱柜，以及相搭配的洗碗机、冰箱等，也可能需要以特殊的形状和尺寸订制的窗户。

在软件开发中也有和这种订制相似的情况，如果你要开发一款一流的软件产品，你可能会自己编写科学计算函数以便获得更快的速度和更高的精度。

> 这就能解释大型公司往往要求的是java、c等语言，它们对软件性能的要求更高



### 两种活动的相似之处：
建造房子和软件开发相似的地方

- **主要的开销还是在人力上**

你只有尽可能地把房子设计好，这样你才不用浪费时间去修正那些本来就可以避免的错误。

![](https://raw.githubusercontent.com/jerrychan807/imggg/master/006tKfTcgy1fshg8xp6ipj30p40eagrb.jpg)

- **多采用现成的东西**

建造一个房子的时候，你不会去试着建造那些能买得到的现成的东西，你会去买洗衣机、烘干机、洗碗机、电冰箱等，除非你是机电方面的巫师。

当开发软件的时候，你也会这么做。你会大量使用高级语言所提供的功能，而不会自己去编写操作系统层次的代码。还会使用很多现成的程序库，比如说一些容器类(container classes)、科学计算函数、用户界面组件、数据库访问组件等。**总之，自己编写那些能找得到的现成的代码通常是没有意义的。**


> 多去了解一些语言的高级特性、各种新的模块，这样才能在开发时有的放矢。(2018.6.20)

- **适当的多层次规划**

适当的多层次规划对于建造建筑物和构建软件都有好处，如果你按错误的顺序构建软件，那么编码、测试和调试都会更难。


- **精心计划**

并非意味着事无巨细的计划或者过度的计划。你可以**把房屋结构性的支撑(structural support)规划清楚**，而在日后再决定是用木地板还是地毯、墙面用什么颜色、材料等。

**一项规划得当的项目能够提升你在后期改变细节(设计)的能力。**

**你对同类软件的开发经验越丰富，在开发新软件时就能认准更多的细节。**


### 隐喻的启发：

用建筑房屋来类比软件构建，有助于解释为什么不同的软件项目能从不同的开发方法中获益。

- **软件开发**：

建筑业中，盖间仓库或者工具房，或是一座医院或者核反应站，你在**规划、设计及质量保证方面所需达到的程度是不一样的**。

同理，在软件开发中，通常你只需要用**灵活的、轻量级的方法**，但有时你就必须得用**严格的、重量级的开发方法**、以达到所需的安全性目标或其他什么目标。

- **软件变动**：

软件的变动在建筑领域也有类似事物。把一堵承重墙移动半尺所需花费的成本，肯定要比仅仅移动一面隔墙更高。同样，对软件进行结构性的修改所需花费的成本，肯定也比仅仅增删一些周边功能更高。

- **超大型项目**：

建筑这一隐喻让人们对超大型的软件项目的认识更加深刻。
**超大型的建筑结构一旦出现问题，后果将非常严重，因此有必要对这样的结构进行超出常规的规划与建设(over-engineered)**。

同理，**对于超大型的软件项目，就需要比一般规模的项目有更高级别的规划设计**。

一套100万行代码的软件系统，平均需要69种文档，其需求规格文档一般有四五千页长，而设计文档常常是需求的两三倍长。不太可能有哪一个人能完全理解这种规模的项目的所有设计细节——甚至只是通读一遍都不那么容易。因此，更充分的准备工作也就理所应当了。

**如果需要创造在经济规模上可以匹敌帝国大厦的庞大的软件项目，那么与之相当水准的技术与管理控制也是必需的。**

- **延伸：**

**按房屋建筑所作的这一隐喻，可以向许多其他方向引申————这也是隐喻这一方法如此强有力的原因。**

有很多常见的软件开发术语都是从建筑这一隐喻中**衍生**出来的：软件架构(建筑学，architecture)、支撑性测试代码(脚手架，scaffolding)、构建(建设，construction)、基础类(foundation classes)以及分离代码(tearing code apart)

---

## 应用软件技术：智慧工具箱

能有效地开发高质量软件的人们，在长年累月中积累了大量的技术，技巧和诀窍。

**技术并不是规矩(rule),它只是分析工具(analysis tools)。好的工匠知道完成某项工作要用哪样工具，也知道该怎样正确地使用。**

**程序员也该这样。编程方面的知识学得越多，你脑中的工具箱就会有更多的分析工具，也会知道该在何时用这些工具，以及怎样正确地使用它们。**

> 对越多概念有基本的了解，就能在日常生产环境中辨别出越多的东西出来(2018.6.25)

在软件领域里，专业的咨询人员有时会让你专用某种软件开发方法而远离其他方法。

这样并不妥当，**因为当你百分之百地依赖于某一方法论时，你就只会用一种方法去看世界了。**

某些情况下，对于你所面临的问题还有其他更好的办法，你可能错失良机。

**这种“工具箱隐喻”能够帮助你把所有的方法、技术及技巧留在脑海中————合适的时候即可拿来就用。**

> 多了解几种编程语言，比如静态、动态语言都要了解一下。You'll be surprised by how much your language shapes the way you think.(2018.6.25)


---

## 组合各个隐喻

**因为隐喻是一种启发式而不是算法，因此它们彼此并不排斥。** 你可以把“写作”同“驾驶”，“狩猎狼人(werewolf)”、“与恐龙一起在焦油坑中淹死”等隐喻组合到一起。

**你可以选用任何一种隐喻或是一些隐喻的组合，只要它能激发你的思维灵感，并让你和团队其他成员更好地沟通。**

**使用隐喻又是件说不清楚的事情。你需要适当地引申它的含义，才能从其蕴含的深刻启发中受益。但若你过分地或者在错误的方向上引申了它的含义，它也会误导你。**

正如人们会误用任何强大的工具一样，你也可能误用隐喻，但它的强大的功效，还会成为你智慧工具箱的一个宝贵部分。

























