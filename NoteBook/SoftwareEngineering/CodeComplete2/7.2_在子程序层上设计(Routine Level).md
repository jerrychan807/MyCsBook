# 7.2 在子程序层上设计(Routine Level)

<!-- TOC -->

- [7.2 在子程序层上设计(Routine Level)](#72-在子程序层上设计routine-level)
    - [子程序的内聚性：](#子程序的内聚性)
    - [写子程序的目标：](#写子程序的目标)
    - [高内聚的好处：](#高内聚的好处)
    - [内聚性的几个层次：](#内聚性的几个层次)
        - [功能的内聚性(functional cohesion)](#功能的内聚性functional-cohesion)
        - [顺序上的内聚性(sequential cohesion)](#顺序上的内聚性sequential-cohesion)
        - [通信上的内聚性(communicational cohesion)](#通信上的内聚性communicational-cohesion)
        - [临时的内聚性(temporal cohesion)](#临时的内聚性temporal-cohesion)
    - [该使用哪种内聚性？](#该使用哪种内聚性)
        - [过程上的内聚性(procedural cohesion)](#过程上的内聚性procedural-cohesion)
        - [逻辑上的内聚性(logical cohesion)](#逻辑上的内聚性logical-cohesion)
        - [巧合的内聚性(coincidental cohesion)](#巧合的内聚性coincidental-cohesion)
    - [总结：](#总结)

<!-- /TOC -->

---



**内聚性(cohesion)**是1974年的一篇论文提出的。

其中一些更为现代的概念，如**抽象**和**封装**等。

通常在**类**这一层次的设计中更为适用(事实上，**抽象**和**封装**在**类**层次上已经很大程度取代了**内聚性**).

但**内聚性的概念**仍然存在，而且在单个子程序这一层次上，仍是设计时常用的**启发式方法**。

---

## 子程序的内聚性：
对子程序而言，内聚性是指**子程序中各种操作之间联系的紧密程度**。

例子：
Cosine()(余弦函数)这样的函数就是**极端内聚**的，因为整个程序**只完成一项功能**。

而CosineAndTan()(余弦与正切)这个函数的内聚性相对较弱，因为它完成了**多于一项的操作**。

##写子程序的目标：
让每一个子程序**只把一件事做好**，不再做任何其他事情。

##高内聚的好处：

- 得到更高的**可靠性**

> **高内聚性**的子程序中有50%没有任何错误，而**低内聚性**的子程序中只有18%是没有错误的。(1986)
> 
> ---
> **耦合度与内聚性之比**最高的那些子程序，其中所含的**错误**是**耦合度与内聚性之比**最低的子程序的7倍之多，而其**修正成本**则为20倍。(1991)

---


## 内聚性的几个层次：
**理解**一些**概念**要比记住一些特定的术语更重要。

### 功能的内聚性(functional cohesion)
**功能的内聚性**是最强也是最好的一种内聚性：让一个子程序**仅执行一项操作**。

例子：

- sin()
- GetCustomerName()
- EraseFile()
- CalculateLoanPayment()
- AgeFromBirthday()

---

不够理想的内聚性的种类：

- 顺序上的内聚性(sequential cohesion)
- 通信上的内聚性(communicational cohesion)
- 临时的内聚性(temporal cohesion)

### 顺序上的内聚性(sequential cohesion)

顺序上的内聚性是指子程序内包含有**需要按特定顺序执行的操作**，这些步骤需要**共享数据**，而且只有在全部执行完毕后才完成了一项完整的功能。




### 通信上的内聚性(communicational cohesion)
通信上的内聚性是指一个子程序中的**不同操作使用了同样的数据**，但**不存在其他任何联系**。



### 临时的内聚性(temporal cohesion)
临时的内聚性是指含有一些因为**需要同时执行才放到一起的操作**的子程序。


---

## 该使用哪种内聚性？
一般来说，除了功能上的的内聚性(functional cohesion)，其他类型的内聚性都是不可取的。

它们都会导致代码组织混乱、难于调试、不便修改。

如果一个子程序具有**不良的内聚性**，那最好还是花功夫重新编写，使其具有更好的**内聚性**，而不是再去花精力精确地诊断问题所在了。

因此，知道应该避免什么是非常有用的，下面是

**不可取的内聚性**

- 过程上的内聚性(procedural cohesion)
- 逻辑上的内聚性(logical cohesion)
- 巧合的内聚性(coincidental cohesion)

---

### 过程上的内聚性(procedural cohesion)
过程上的内聚性是指一个子程序中的**操作是按特定的顺序**进行的。


### 逻辑上的内聚性(logical cohesion)
逻辑上的内聚性是指若干操作被放入同一个子程序中，通过**传入的控制标志**选择执行其中的一项操作。


### 巧合的内聚性(coincidental cohesion)
巧合的内聚性是指子程序中**各个操作之间没有任何可以看到的关联**，它也可称为“无内聚性”或“混乱的内聚性”。

---

## 总结：

这些术语没有哪个是神秘的或者神圣不可侵犯的，需要理解的是**其中的想法**，而不是那些术语。

编写子程序时，要集中于**功能上的内聚性**。





